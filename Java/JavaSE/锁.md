## AQS

AQS 全称为 AbstractQueuedSynchronizer 抽象队列同步器

## CAS

全称为 Compare and Swap ，即比较-替换。假设有三个操作数：内存值 V 、旧的预期值 A 、要修改的值 B ，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true ，否则什么都不做并返回 false 。当然 CAS 一定要 volatile 变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A ，只要某次 CAS 操作失败，永远都不可能成功

## 乐观锁

乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新时会判断此期间数据是否被更新采取在写时先读出当前版本号，然后加锁操作(比较跟上一次的版本号，如果一样则更新)，如果失败则要重复读-比较-写的操作java中的乐观锁基本通过 `CAS` 操作实现的，`CAS` 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败

## 悲观锁

悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 `block` 直到拿到锁。 java中的悲观锁就是 `Synchronized` ，`AQS` 框架下的锁则是先尝试 `CAS` 乐观锁去获取锁，获取不到， 才会转换为悲观锁，如 `RetreenLock`

## 自旋锁

自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 线程自旋是需要消耗 cpu 的，说白了就是让 cpu 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cpu 自旋做无用功，所以需要设定一个自旋等待的最大时间。

如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态

### 自旋锁优缺点

自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu ，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁

### 自旋锁的开启

| 版本   | JDK1.6             | JDK1.7 |
|------|--------------------|--------|
| 开启方式 | X:+UseSpinning     | 由jvm控制 |
| 次数控制 | XX:PreBlockSpin=10 | 由jvm控制 |

## Synchronized同步锁

synchronized 它可以把任意一个非 NULL 的对象当作锁。**他属于独占式的悲观锁，同时属于可重入锁**

### Synchronized作用范围

- 作用于方法时，锁住的是对象的实例(this)
- 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久代PermGen（jdk1.8 则是 metaspace），永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程
- synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列， 当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中

### Synchronized核心组件

- **`Wait Set：`** 哪些调用wait方法被阻塞的线程被放置在这里
- **`Contention List：`** 竞争队列，所有请求锁的线程首先被放在这个竞争队列中
- **`Entry List：`** Contention List 中那些有资格成为候选资源的线程被移动到Entry List中
- **`OnDeck：`** 任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck
- **`Owner：`** 当前已经获取到所资源的线程被称为Owner
- **`!Owner：`** 当前释放锁的线程

### Synchronized实现

![Synchronized实现.drawio.svg](锁/Synchronized实现.drawio.svg)

### JDK1.6后的优化

## ReentrantLock

### Lock接口主要方法

### tryLock、lock和lockInterruptibly

## ReentrantLock与synchronized

## 非公平锁

## 公平锁

## 可重入锁(递归锁)

## 读写锁

## 独占锁

## 共享锁

## 锁状态

### 重量级锁(Mutex Lock)

### 轻量级锁

### 偏向锁

### 锁升级

### 分段锁

## 同步锁与死锁

### 同步锁

### 死锁

### 锁优化思路

#### 减少锁持有时间

#### 减小锁粒度

#### 锁分离

#### 锁粗化

## Condition类和Object类锁方法
