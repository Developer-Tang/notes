## Redis是什么

Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。 它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库

Redis 作为一个内存数据库：

- 性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS
- 单进程单线程，是线程安全的，采用 IO 多路复用机制
- 丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等
- 支持数据持久化
- 可以将内存中数据保存在磁盘中，重启时加载
- 主从复制，哨兵，高可用
- 可以用作分布式锁
- 可以作为消息中间件使用，支持发布订阅

## Redis与Memcached的区别

- Memcached 所有的值均是字符串， Redis 支持更为丰富的数据类型
- Redis 的 Value 值最大达到 1GB ， 而 Memcached 只有 1MB
- Redis 支持持久化数据

## 数据结构

### String

String 是二进制安全的，也就是 String 可以包含任何数据。如：数字、字符串、序列化对象或图片。 String 类型最大的存储大小为 `512M`

常用场景：

- 缓存： 将部分信息缓存至 Redis 中，较少服务器、关系型数据库压力
- 计数器： Redis 是单线程模型，所有可以通过该特性实现分布式计数
- 分布式 Session ： 通过 SpringSession + Redis 实现分布式 Session 共享

### Hash

值为键值对结构，比 String 存储对象更加节省空间，更加直观

常用场景：

- 缓存：比 String 节省内存，且利于维护缓存信息，可以根据指定键修改

### List

列表。 Redis 中的 List 通过双向链表实现，有序且 value 可重复，可以模拟队列和栈

常用场景：

- 时间轴：比如通过添加节点的方式记录用户发布文章的记录

### Set

集合。与 List 不同之处在于无序无下标、元素不可重复和支持集合间操作如交集、并集和差集等

常用场景：

- 共同特征：比如通过记录用户兴趣集合的交集获取共同的特征
- 记录参与：记录哪些用户参与了，如：点赞、收藏、转发…

### Zset

有序集合。保留了 Set 元素不可重复的特性，额外添加了根据 score 分数排序的功能保证了有序性

常用场景：

- 排行榜：通过一些数值对数据进行排列，如通过用户参与次数进行排序获取排行榜

## Redis事务

### Redis事务的概念

Redis 事务的本质是通过 MULTI 、 EXEC 、 WATCH 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中

- **DISCARD** ：取消事务，放弃执行事务块内的所有命令
- **EXEC** ：执行所有事务块内的命令
- **MULTI** ：标记一个事务块的开始
- **WATCH :** Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
- **UNWATCH** ：取消 WATCH 命令对所有 key 的监视

### Redis事务的三个阶段

1. 事务开始 MULTI
2. 命令入队
3. 事务执行 EXEC

PS: 事务执行过程中，如果服务端收到有 EXEC 、DISCARD 、 WATCH 、 MULTI 之外的请求，将会把请求放入队列中排队

### Redis事务的隔离性

Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此， **Redis 的事务是具有隔离性** 的

### Redis事务不具备原子性

Redis 中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚操作。事务中任意命令执行失败，其余的命令仍会被执行

## Redis持久化机制

### RDB

通过备份快照的方式进行持久化存储，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件， 达到数据恢复

**优点**

- 只有一个文件 dump.rdb ， 方便持久化
- 容灾性好， 一个文件可以保存到安全的磁盘
- 性能最大化， fork 子进程来完成写操作， 让主进程继续处理命令， 所以是 IO 最大化。使用单独子 进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能)
- 相对于数据集大时， 比 AOF 的启动效率更高
- 恢复数据的速度快

**缺点**

- 数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失
- 新老版本无法兼容 RDB 格式

### AOF

所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储保存为 aof 文件

**优点**

- 数据安全， AOF 持久化可以配置 appendfsync 属性，有 always ，每进行一次命令操作就记录到 aof 文件中一次
- 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题
- AOF 机制的 rewrite 模式。 AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写）， 可以删除其中的某些命令（比如误操作的 flushall )

**缺点**

- AOF 文件比 RDB 文件大，且恢复速度慢
- 数据集大的时候，比 RDB 启动效率低
- AOF 开启后，会对写的 QPS 有所影响

## 缓存淘汰策略

Redis 的内存淘汰策略是指用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据

**Redis 的缓存淘汰策略有：**

- **`noeviction :`** 当内存不足以容纳新写入数据时，新写入操作会报错
- **`allkeys-lru :`** 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key
- **`allkeys-random :`** 当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key
- **`volatile-lru :`** 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key
- **`volatile-random :`** 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key

PS：例：`redis.conf` 中配置 `maxmemory-policy noeviction`

## 缓存失效策略

Redis 为了更好的使用内存，用一定的内存丢失来换取内存的使用率

### 定期过期策略

Redis 每 100ms 随机抽取一部分有过期时间的 key ，检查这些 key 是否过期，过期就删除

### 惰性过期策略

Redis 在获取key之前会先检查该 key 是否过期，未过期就返回，过期了就删除 key 且不返回任何数据

### 定时过期策略

每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量
